/*----------------------------------------------------------------------*/
/* FAT file system sample project for FatFs            (C)ChaN, 2009    */
/*----------------------------------------------------------------------*/

#include "config.h"
#include <avr/io.h>
#include <avr/pgmspace.h>
#include <avr/interrupt.h>
#include <string.h>
#include <util/delay.h>
#include "uart.h"
#include "xitoa.h"
#include "ff.h"
#include "diskio.h"
#include "rtc.h"
#include "can_lib.h"

#define NB_TARGET 1
#define ID_TAG_BASE 128

void can(void);
void req_sensor_data(U8 pakke, U8 node);

DWORD acc_size;				/* Work register for fs command */
WORD acc_files, acc_dirs;
FILINFO Finfo;
#if _USE_LFN
char Lfname[_MAX_LFN+1];
#endif


BYTE Line[120];				/* Console input buffer */

FATFS Fatfs[2];				/* File system object for each logical drive */
BYTE Buff[1024];			/* Working buffer */

volatile WORD Timer;		/* 100Hz increment timer */


#if _MULTI_PARTITION != 0
const PARTITION Drives[] = { {0,0}, {0,1} };
#endif

/*---------------------------------------------------------*/
/* 100Hz timer interrupt generated by OC2                  */
/*---------------------------------------------------------*/


ISR(TIMER2_COMP_vect)
{
	Timer++;			/* Performance counter for this module */
	disk_timerproc();	/* Drive timer procedure of low level disk I/O module */
}


/*---------------------------------------------------------*/
/* User Provided Timer Function for FatFs module           */
/*---------------------------------------------------------*/
/* This is a real time clock service to be called from     */
/* FatFs module. Any valid time must be returned even if   */
/* the system does not support a real time clock.          */
/* This is not required in read-only configuration.        */


DWORD get_fattime ()
{
	RTC rtc;


	/* Get local time */
	rtc_gettime(&rtc);

	/* Pack date and time into a DWORD variable */
	return	  ((DWORD)(rtc.year - 1980) << 25)
			| ((DWORD)rtc.month << 21)
			| ((DWORD)rtc.mday << 16)
			| ((DWORD)rtc.hour << 11)
			| ((DWORD)rtc.min << 5)
			| ((DWORD)rtc.sec >> 1);
}

static
void IoInit ()
{
   OCR2A = 90-1;      // Timer2: 100Hz interval (OC2)
   TCCR2A = 0b00001101;

   TIMSK2 = 0b00000010;   // Enable TC2.oc interrupt

   rtc_init();         // Initialize RTC
   can_init(0);
   uart_init();
}


/*-----------------------------------------------------------------------*/
/* Main                                                                  */


int main (void)
{
	DWORD p1, p2, p3;
	BYTE res, b1;
	WORD w1;
	UINT s1, s2, cnt;
	DWORD ofs, sect = 0;
	RTC rtc;
	FATFS *fs;
	DIR dir;				/* Directory object */
	FIL file1, file2;			/* File object */

	IoInit();

    	uart_put(84);
	/* Join xitoa module to uart module */
	xfunc_out = (void (*)(char))uart_put;
    _delay_ms(2000);
	xprintf(PSTR("System startet\n"));
    xprintf(PSTR("Initialize disk 0\n"));    
	xprintf(PSTR("rc=%d\n"), (WORD)disk_initialize(0));
    xprintf(PSTR("Initialize logical drice 0\n"));
    xprintf(PSTR("rc=%d\n"), (WORD)f_mount(0, &Fatfs[0]));
    xprintf(PSTR("Opening file hej\n"));
    xprintf(PSTR("rc=%d\n"), (WORD)f_open(&file1, "hej",FA_WRITE)); 

    while(1) {
            can();
    }
}

void can(void)
{
    U8 i,j;

    U8 response_buffer[3][8];
    st_cmd_t response_msg[3];
    U8 databuffer[6][8];
    U8 bufferindex = 0;
    U8 buffersize = 8;

    char num_buffer = 1;

    // --- Init variables
    
    for (i=0; i<num_buffer; i++) {
        response_msg[i].pt_data = &response_buffer[i][0];
        response_msg[i].status = 0;
    }

    for (j=0; j<num_buffer; j++) {
        for(i=0; i<9; i++) {
            response_buffer[j][i]=0; // Nulstiller buffer
        }
    }

    for (i=0; i<num_buffer; i++) {
            response_msg[i].id.std = ID_TAG_BASE;
            response_msg[i].ctrl.ide = 0;
            response_msg[i].ctrl.rtr = 0;
            response_msg[i].dlc = 8;
            response_msg[i].cmd = CMD_RX_DATA_MASKED;
            // --- Rx Command
            while(can_cmd(&response_msg[i]) != CAN_CMD_ACCEPTED);
    }
    while (1)
    {
        // Venter pÃ¥ der kommer data fra node
        if (can_get_status(&response_msg[0]) == CAN_STATUS_COMPLETED){
            if (bufferindex >= buffersize){
                xprintf(PSTR("Buffer full error\n"));
            } else {
                for (i=0; i<9; i++) {
                        databuffer[bufferindex][i] = response_buffer[0][i];
                        response_buffer[0][i] = 0;
                }
                bufferindex++;
            }
            response_msg[0].id.std = ID_TAG_BASE;
            response_msg[0].ctrl.ide = 0;
            response_msg[0].ctrl.rtr = 0;
            response_msg[0].dlc = 8;
            response_msg[0].cmd = CMD_RX_DATA_MASKED;
            // --- Rx Command
            while(can_cmd(&response_msg[0]) != CAN_CMD_ACCEPTED);
        } 
        if (bufferindex >= 4) {
            for (i=0; i<bufferindex; i++) {         
                xprintf(PSTR("Buf: %d"), i), 
                xprintf(PSTR(", Data1: %03d"), databuffer[i][0]);
		        xprintf(PSTR(", Data2: %03d"), databuffer[i][1]);
		        xprintf(PSTR(", Data3: %03d"), databuffer[i][2]);
    		    xprintf(PSTR(", Data4: %03d"), databuffer[i][3]);
	    	    xprintf(PSTR(", Data5: %03d"), databuffer[i][4]);
		        xprintf(PSTR(", Data6: %03d"), databuffer[i][5]);
		        xprintf(PSTR(", Data7: %03d"), databuffer[i][6]);                
    		    xprintf(PSTR(", Data8: %03d"), databuffer[i][7]);
	    	    xprintf(PSTR("\r\n"));
            }
            bufferindex = 0;
        }
    }
}

void req_sensor_data(U8 pakke, U8 node)
{
	U8 tx_remote_buffer[9];
   	st_cmd_t tx_remote_msg;

	tx_remote_msg.pt_data = &tx_remote_buffer[0];
	tx_remote_msg.status = 0;
	
	tx_remote_buffer[0]=pakke; // Nulstiller buffer

    tx_remote_msg.id.std = ID_TAG_BASE+node;
    tx_remote_msg.ctrl.ide = 0;
    tx_remote_msg.ctrl.rtr = 1;
    tx_remote_msg.dlc = 8; // Antal data bytes der skal modtages 
    tx_remote_msg.cmd = CMD_TX_DATA;
    // --- Tx Command
    while(can_cmd(&tx_remote_msg) != CAN_CMD_ACCEPTED);

	// --- Wait for Tx remote completed
        while(can_get_status(&tx_remote_msg) == CAN_STATUS_NOT_COMPLETED);
}
